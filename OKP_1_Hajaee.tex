\documentclass[11pt,oneside,a4paper]{article}
%\usepackage{ucs}
\usepackage{url}
\usepackage{hyperref}
\usepackage{lmodern}
\usepackage[pdftex]{graphicx}
\usepackage{textcomp}
\usepackage[latin1]{inputenc}
\usepackage[finnish]{babel}
\usepackage[T1]{fontenc}
\author{Jari Koskinen, Hansi Keijonen, Eero Laine}
\title{Ohjelmointikielten periaatteet 2013} 




\begin{document}
% kirjoita nimiä
\maketitle

\pagebreak

\tableofcontents

\pagebreak

\section{D ohjelmointikieli}
D on kehitetty korjaamaan C ja C++ kielten puutteita ja samalla siihen on lisätty paljon ominaisuuksia, joiden ansiosta...
D kielessä on ominaisuuksia plaaplaa... 
\begin{itemize}
\item Automaattinen roskienkeruu
\item Vahva tyypitys
\item Käännös natiivikoodiksi
\item Rinnakkaisuuden tuki
\end{itemize}
Lisää kielestä plaaplaa

\section{Erlang ohjelmointikieli}
Erlang on funktionaalinen kieli, joka on tarkoitettu alunperin puhelinkeskusten ohjelmointiin. Tästä syystä kieli tukee hyvin rinnakkaisuutta...
--------------------------
Ohjelma, joka tulostaa ensimmäisen syöttölukua suuremman fibonaccin luvun, näyttää Erlangilla seuraavalta. Kommentit alkavat \%-merkillä. Numeroidut kommentit, 
jotka selventävät ohjelman toimintaa, on selitetty koodin alla. 
\begin{verbatim}
-module(fibo). %1
-export([fibo/1, compfibo/2, fiboplus/1]). %2
     fiboplus(N) -> compfibo(N,0) . %3
     compfibo(N,S) -> Curr = fibo(S),%4
          if Curr > N -> Curr;
          true -> compfibo(N,S+1)
          end . 
fibo(0) -> 0 ; %5
fibo(1) -> 1 ;
fibo(N) when N > 1 -> fibo(N-1) + fibo(N-2) .
\end{verbatim}
\%1: Ensimmäisenä tulee määritellä moduulin nimi, tässä tapauksessa 'fibo'.\newline
\%2: Jotta moduulissa olevia metodeita pystytään ohjelman ulkopuolella, tulee ne määritellä export-lauseella ulkopuolelta kutsuttaviksi. Jokaisen määrityksen yhteydessä
ilmoitetaan kutsussa tarvittavien parametrien määrä.\newline
\%3: Varsinainen päämetodi. Tätä kutsutaan halutulla parametrilla. Parametrina annetaan siis luku, jota suuremman (ensimmäisen) fibonaccin luvun ohjelma laskee.
Kyseessä oleva metodi kutsuu ainoastaan apumetodia compfibo, lisäten mukaan apuparametrin, joka pitää kirjaa siitä, monettako fibonaccin lukua kulloinkin haetaan.\newline
\%4: compfibo-metodi tallettaa ensimmäisenä muuttujaan Curr fibonaccin sarjan S:nen luvun. Jos luku on suurempi kuin alkuperäinen annettu luku N, palautetaan se. \newline
Muussa tapauksessa kutsutaan compfibo-metodia uudelleen siten, että parametrin S arvoa kasvatetaan yhdellä, jotta seuraavalla kutsukerralla tutkittaisiin järjestyksessä seuraavaa
fibonaccin lukua.\newline
\%5: fibo-metodi laskee fibonaccin N:nen luvun. Toimintatapa metodissa on hahmonsovitus, joka on yleinen myös eräässä toisessa ohjelmointikielessä, Haskellistsa. 
\section{Kielten alkiorakenteen vertailu}
D on vahvasti tyypitetty kieli...
Seuraavat tietotyypit ovat tuettuna:
\begin{itemize}
\item Int
\item Double
\item Char
\item ...
\end{itemize}

D : Tunnukset alkavat kirjaimella, '\textunderscore'-merkillä tai universal alphalla (jotainhämminkiä tässä, ota selvää!). 
Seuraavina merkkeinä voi olla mikä tahansa edellisistä ja tunnuksen pituus voi olla mielivaltainen. 
Kahdella '\textunderscore'-merkillä alkavat tunnukset ovat varattuja.   

D: avainsanat ovat varattuja tunnuksia
\begin{verbatim}
abstract alias align asm assert auto body
bool break byte
case cast catch cdouble cent cfloat char class const 
continue creal dchar debug default delegate delete
deprecated do double else enum export extern false
final finally float for foreach foreach_reverse function 
goto idouble if ifloat immutable import in inout int 
interface invariant ireal is lazy long macro mixin 
module new nothrow null out override package 
pragma private protected public pure real ref 
return scope shared short static struct super
switch synchronized template this throw
truetry typedef typeid typeof ubyte ucent uint 
ulong union unittest ushort version void
volatile wchar while with __FILE__
 __LINE__ __gshared __traits __vector __parameters
\end{verbatim}
\begin{itemize}
\item merkkijonoliteraalit:
		wysiwyg-merkkijonot 
		lainausmerkein ymidyt merkkijonot
		heksamerkkijonot
		erotin-merkkijonot
		token-merkkijonot
\item merkkiliteraalit:
		yksi merkki tai escape-character -merkien sisalla
\item kokonaislukuliteraalit
		mieti miten kasitellaan
\item 	liukulukuliteraalit
		mieti miten kasitellaan
\end{itemize}
	
	
	


%\begin{verbatim}
%	/* blokkikommentti */ 
%	//rivin perŠŠn tuleva kommentti 
%	/+ nesting blokkikommentti +/
%\end{verbatim}
\subsection{Esimerkkejä ohjelmakoodista}
...
...
\subsection{Ratkaisujen vertailua}
...
...
\section{Kielten syntaksi}
\subsection{Rakenne}
Näin tulostetaan Hello World! D-kielellä.
\begin{verbatim}
import std.stdio;

void main() {
 writeln("Hello World!");
}
\end{verbatim}

Vastaavasti Erlangissa Hello World! toteutetaan näin:
\begin{verbatim}
-module(hello).
-export([hello_world/0]).

hello_world() -> 
  io:fwrite("hello, world\n").
\end{verbatim}
joka tulostaa konsolille kuvan \ref{konsoli2} mukaisesti.

\begin{figure}[tbh]
%\begin{figure}[tbh] t= top, b = bottom, h=here
%\begin{center}
%\includegraphics[width=0.5\textwidth]{konsoli2.png}
%\rotatebox{90}{\includegraphics[scale=.75]{esimerkki.pdf}}
\caption{Tuloste konsolilla}
\label{konsoli2}
%\end{center}
\end{figure}

Iteroinnissa C-kielestä tuttu tapa on mahdollinen

\begin{verbatim}
import std.stdio;

void main() {
  for(int i=0; i<10; i++) {
    writeln("Rivi: ", i);
  }
}
\end{verbatim}
Iteraatio voidaan tehdä myös seuraavasti:
\begin{verbatim}
import std.stdio;

void main() {
  foreach(i; 0 .. 10) {
    writeln("Rivi: ", i);
  }
}
\end{verbatim}

ja tuloste näyttää kuvan \ref{konsoli1} mukaiselta.
\begin{figure}[tbh]
%\begin{figure}[tbh] t= top, b = bottom, h=here
\begin{center}
\includegraphics[width=1.0\textwidth]{konsoli1.jpg}
%\rotatebox{90}{\includegraphics[scale=.75]{esimerkki.pdf}}
\caption{Tuloste konsolilla}
\label{konsoli1}
\end{center}
\end{figure}

\section{Yhtenveto}
Yhteenvetona todettakoon, että D ja Erlang poikkeavat toisistaan...
\end{document}