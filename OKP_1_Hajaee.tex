\documentclass[11pt,oneside,a4paper]{article}
%\usepackage{ucs}
\usepackage{url}
\usepackage{hyperref}
\usepackage{lmodern}
\usepackage[pdftex]{graphicx}
\usepackage{textcomp}
\usepackage[latin1]{inputenc}
\usepackage[finnish]{babel}
\usepackage[T1]{fontenc}
\author{Jari Koskinen, Hansi Keijonen, Eero Laine}
\title{Ohjelmointikielten periaatteet 2013} 




\begin{document}
% kirjoita nimiä
\maketitle

\pagebreak

\tableofcontents

\pagebreak

\section{D-ohjelmointikieli}
D-ohjelmointikieli on C/C++ kielten pohjalta kehitetty ja sen pääasiallisena kehittäjänä on alusta lähtien toiminut ohjelmointikielten kääntäjiin erikoistunut Walter Bright. Kehitystyö on alkanut vuonna 1999 ja ensimmäinen julkaisu kääntäjästä on tehty vuonna 2001 Brightin omistaman yhtiön Digital Marsin toimesta. Ensimmäinen vakiintunut versio 1.0 julkaistiin kuitenkin vasta vuonna 2007. Nykyinen versio on 2.0 ja kielen kehitys jatkuu edelleen, kun mukaan on liittynyt useita kehittäjiä Brightin lisäksi. Version 2.0 pohjalta on julkaistu vuonna 2010 Andrei Alexandrescun kirjoittama kirja: The D Programming Language, jonka myötä version voidaan katsoa vakiintuneen. Versio 1.0 kattoi kolme ohjelmointiparadigmaa: imperatiivinen, oliopohjainen ja metaohjelmointi. 2.0 versio toi mukanaan tuen funktionaaliselle ohjelmoinnille ja aktorimallin rinnakkaisohjelmointiin. Tässä kirjoituksessa käsitellään kielen versiota 2.0. Kieli sisältää paljon uudistuksia, jotka ovat parannuksia C/C++ kieliin tai muiden, kuten C\#:n 
ja Javan hyödylliseksi havaittuja ominaisuuksia. Samalla kielestä on pyritty jättämään pois C/C++ kielten taaksepäin yhteensopivuuden asettamia rajoitteita. 

D on moniparadigmainen, oliopohjainen ja imperatiivinen ohjelmointikieli. D tarjoaa tuen myös funktionaaliselle ja metaohjelmoinnille. D:llä kirjoitetut ohjelmat käännetään käännös- ja linkitysvaiheen kautta kohdeympäristön konekielelle. Ohjelmoijalla on täysi pääsy laitetasolle, joten se soveltuu myös käyttöjärjestelmien ohjelmointiin. Muistinhallinta voidaan jättää automatiikan huoleksi, koska D sisältää C\#:n ja Javan tapaan roskienkeruun, mutta sallii muistinkäsittelyn myös C/C++:lle tyypillisen tapaan. Perintä on toteutettu yksinkertaisella perinnällä, rajapinnoilla ja mixineillä. Kielen syntaksi muistuttaa hyvin paljon C++ kieltä.

Alla on esimerkki ohjelmasta, joka palauttaa annettua lukua suuremman fibonaccin luvun.

\begin{verbatim}
import std.stdio;
import std.conv;

void main(string[] args) {
uint f;
 try {
  f = parse!uint(args[1]);
 }
 catch {
  writeln("Error in arguments!");
  return;
 }
 writeln(args[1]);
 writeln(fib(f));
}

ulong fib(uint n) {
 ulong iter(ulong fib_1, ulong fib_2) {
  return fib_2 > n ? fib_2 : iter(fib_1 + fib_2, fib_1);
 }
 return iter(1, 0);
}
\end{verbatim}

D kielessä on seuraavia ominaisuuksia:
\begin{itemize}
\item Automaattinen roskienkeruu
\item Vahva tyypitys
\item Käännös natiivikoodiksi
\item Rinnakkaisuuden tuki
\item Onko lista järkevä muoto???
\end{itemize}

\section{Erlang ohjelmointikieli}
Erlang on funktionaalinen kieli, joka on tarkoitettu hajautettujen järjestelmien ohjelmointiin. Erlang soveltuu tosiaikajärjestelmien ja laajasti skaalautuvien järjestelmien kehittämiseen, kuten puhelinkeskukset, pankkijärjestelmät ja sähköinen liiketoiminta. Kieli sisältää laajan tuen rinnakkaisuudelle ja mahdollistaa erittäin vikasietoisten järjestelmien kehittämisen. Kielen kehittämisen aloitetti Joe Armstrong vuonna 1986 Ericsson-yhtiössä. Alunperin se on ollut suljetussa käytössä, mutta julkaistiin avoimena vuonna 1998. Erlangin tietotyypit ovat dynaamisesti ja vahvasti tyypitettyjä. 

Ohjelma, joka tulostaa ensimmäisen syöttölukua suuremman fibonaccin luvun, näyttää Erlangilla seuraavalta. Kommentit alkavat \%-merkillä. Numeroidut kommentit, 
jotka selventävät ohjelman toimintaa, on selitetty koodin alla. 
\begin{verbatim}
-module(fibo). %1
-export([fibo/1, compfibo/2, fiboplus/1]). %2
     fiboplus(N) -> compfibo(N,0) . %3
     compfibo(N,S) -> Curr = fibo(S),%4
          if Curr > N -> Curr;
          true -> compfibo(N,S+1)
          end . 
fibo(0) -> 0 ; %5
fibo(1) -> 1 ;
fibo(N) when N > 1 -> fibo(N-1) + fibo(N-2) .
\end{verbatim}
\%1: Ensimmäisenä tulee määritellä moduulin nimi, tässä tapauksessa 'fibo'.\newline
\%2: Jotta moduulissa olevia metodeita pystytään ohjelman ulkopuolella, tulee ne määritellä export-lauseella ulkopuolelta kutsuttaviksi. Jokaisen määrityksen yhteydessä
ilmoitetaan kutsussa tarvittavien parametrien määrä.\newline
\%3: Varsinainen päämetodi. Tätä kutsutaan halutulla parametrilla. Parametrina annetaan siis luku, jota suuremman (ensimmäisen) fibonaccin luvun ohjelma laskee.
Kyseessä oleva metodi kutsuu ainoastaan apumetodia compfibo, lisäten mukaan apuparametrin, joka pitää kirjaa siitä, monettako fibonaccin lukua kulloinkin haetaan.\newline
\%4: compfibo-metodi tallettaa ensimmäisenä muuttujaan Curr fibonaccin sarjan S:nen luvun. Jos luku on suurempi kuin alkuperäinen annettu luku N, palautetaan se. \newline
Muussa tapauksessa kutsutaan compfibo-metodia uudelleen siten, että parametrin S arvoa kasvatetaan yhdellä, jotta seuraavalla kutsukerralla tutkittaisiin järjestyksessä seuraavaa
fibonaccin lukua.\newline
\%5: fibo-metodi laskee fibonaccin N:nen luvun. Toimintatapa metodissa on hahmonsovitus, joka on yleinen myös eräässä toisessa ohjelmointikielessä, Haskellissa. 
\section{Kielten alkiorakenteen vertailu}
D-kielen tunnuksissa voi olla kirjaimia, alaviivoja tai universal alphoja (wtf), ja ensimmäistä merkkiä lukuunottamatta myös numerot ovat käytössä. Tunnusta ei voi myöskään aloittaa kahdella alaviivalla. D-kieli on "case sensitive", eli isot ja pienet kirjaimet on eroteltu toisistaan. Varattuja sanoja on noin sata, esimerkiksi Javastakin löytyvät termit abstract, final, switch ja class.

Merkkijonoliteraali on D:ssä joko merkkijono kaksinkertaisissa lainausmerkeissä, "wysiwyg"-merkkijono, ohjausmerkki, rajattu merkkijono, järjestetty merkkijono tai heksamerkkijono (?). Rivin loppumista kuvaava \begin{verbatim}"\n"\end{verbatim} lasketaan yhdeksi merkiksi kaikissa merkkijonoliteraaleissa.

"Wysiwyg" on lyhennys sanoista "what you see is what you get", ja "wysiwyg"-merkkijonoissa
	kaikki merkit toistetaan uskollisesti. "Wysiwyg"-merkkijonot voidaan erotella joko "r"- tai
	"`"-merkein. Merkkijonot \begin{verbatim}r"c:\root\foo.exe" ja `c:\root\foo.exe`\end{verbatim} ovat esimerkkejä "wysiwyg"-merkkijonoista.
	Merkkijonot kaksinkertaisissa lainausmerkeissä ovat "-merkkien ympäröimiä. Ohjausmerkkejä
	voi sulauttaa näihin merkkijonoihin monista ohjelmointikielistä tutulla "\"-merkintätavalla, 
	kuten esimerkiksi merkkijonossa "c:\\root\\foo.exe".
	Heksamerkkijonot mahdollistavat merkkijonoliteraalien luomisen 	heksa

\begin{verbatim}
abstract alias align asm assert auto body
bool break byte
case cast catch cdouble cent cfloat char class const 
continue creal dchar debug default delegate delete
deprecated do double else enum export extern false
final finally float for foreach foreach_reverse function 
goto idouble if ifloat immutable import in inout int 
interface invariant ireal is lazy long macro mixin 
module new nothrow null out override package 
pragma private protected public pure real ref 
return scope shared short static struct super
switch synchronized template this throw
truetry typedef typeid typeof ubyte ucent uint 
ulong union unittest ushort version void
volatile wchar while with __FILE__
 __LINE__ __gshared __traits __vector __parameters
\end{verbatim}
\begin{itemize}
\item merkkijonoliteraalit:
		wysiwyg-merkkijonot 
		lainausmerkein ymidyt merkkijonot
		heksamerkkijonot
		erotin-merkkijonot
		token-merkkijonot
\item merkkiliteraalit:
		yksi merkki tai escape-character -merkien sisalla
\item kokonaislukuliteraalit
		mieti miten kasitellaan
\item 	liukulukuliteraalit
		mieti miten kasitellaan
\end{itemize}
	
	
	


%\begin{verbatim}
%	/* blokkikommentti */ 
%	//rivin perŠŠn tuleva kommentti 
%	/+ nesting blokkikommentti +/
%\end{verbatim}
\subsection{Esimerkkejä ohjelmakoodista}
...
...
\subsection{Ratkaisujen vertailua}
...
...
\section{Kielten syntaksi spesifikaatioissa}

D-kielen referenssidokumentti löytyy osoitteesta http://dlang.org. 


ja tuloste näyttää kuvan \ref{konsoli1} mukaiselta.
\begin{figure}[tbh]
%\begin{figure}[tbh] t= top, b = bottom, h=here
\begin{center}
\includegraphics[width=1.0\textwidth]{konsoli1.jpg}
%\rotatebox{90}{\includegraphics[scale=.75]{esimerkki.pdf}}
\caption{Tuloste konsolilla}
\label{konsoli1}
\end{center}
\end{figure}

\section{Yhtenveto}
Yhteenvetona todettakoon, että D ja Erlang poikkeavat toisistaan...
\end{document}