\documentclass[11pt,oneside,a4paper]{article}
\usepackage{url}
\usepackage{hyperref}
\usepackage{lmodern}
\usepackage[pdftex]{graphicx}
\usepackage{textcomp}
\usepackage[utf8]{inputenc}
\usepackage[finnish]{babel}
\usepackage[T1]{fontenc}
\title{D- ja Erlang-kielten datan kapselointi}
\author{Hansi Keijonen, Jari Koskinen, Eero Laine}

\begin{document}

\maketitle

\newpage

\section{Jarin osuus}
\subsection{Rakenteiset tyypit}
Alkeistyypeistä voidaan muodostaa taulukoita, joita on kahdenlaisia. Yksi
taulukoista on yleinen perustapaus array, jollainen löytyy myös C/C++-kielistä
\cite{KRR88}. Taulukon alkioihin voidaan viitata indeksin avulla.
\begin{verbatim}
int[] lukuja;
lukuja[11] = 13;
\end{verbatim}

Toinen taulukkomuoto on avaimen ja arvon sisältävä pari, associative array.
Taulukon alkio sisältää arvon ja siihen viittaava indeksi voi olla esimerkiksi
merkkijono: 
\begin{verbatim}
  int[string] kuukausi;
  
  kuukausi["tammikuu"] = 1;
  kuukausi["helmikuu"] = 2;
  
  writeln("Tammikuu=", kuukausi["tammikuu"]);
\end{verbatim}
Koodi tulostaa:
\begin{verbatim}
Tammikuu=1
\end{verbatim}

Lisäksi taulukko voidaan jättää dynaamiseksi, määrittämällä sen pituudeksi [],
jolloin sille voidaan osoittaa jokin olemassa oleva taulukko myöhemmin koodissa.

Alkeistyypeistä voidaan myös muodostaa tietueet struct tai union. Molemmat
vastaavat C/C++-kielen vastaavia rakenteita \cite{KRR88} ja ovat arvotyyppejä
\cite{DLA13}. Struct määritellään, ja sitä käytetään seuraavasti:

\begin{verbatim}
struct palkansaaja{
  int palkka;
  string titteli;
}

void main() {
  palkansaaja[5] palkolliset;
  palkolliset[1].palkka = 4500;
  palkolliset[1].titteli = "ohjelmoija";

  write(palkolliset[1].titteli, " tienaa ");
  writeln(palkolliset[1].palkka, " kuukaudessa");
}
\end{verbatim}

Union eroaa structista siten, että muuttujien arvot on talletettu muistissa
samaan kohtaan \cite{ALE10};\cite{KRR88}, riippumatta niiden tyypistä ja
pituudesta. Kääntäjän tehtävä on varata riittävä määrä muistia suurimman tyypin
mukaisesti. Yhden muuttujan arvon muuttaminen vaihtaa muuttujille varatun
muistin sisällön. Seuraava esimerkki havainnollistaa tätä:
\begin{verbatim}
union moniTyyppi{
  int iluku;
  uint uiluku;
  ubyte ubluku;
}

void main() {
  moniTyyppi luku;
  luku.iluku = 6200;
  writeln("int: ", luku.iluku);
  writeln("uint: ", luku.uiluku);
  writeln("ubyte: ", luku.ubluku);
  luku.iluku = -6200;
  writeln("int: ", luku.iluku);
  writeln("uint: ", luku.uiluku);
  writeln("ubyte: ", luku.ubluku);
}
\end{verbatim}
Ohjelma tulostaa seuraavasti:

\begin{verbatim}
int: 6200
uint: 6200
byte: 56
int: -6200
uint: 4294961096
ubyte: 200
\end{verbatim}

Lisäksi voidaan luoda dymaaninen taulukko, joka tarkoittaa sitä, että taulukkoon
voidaan myöhemmin sijoittaa taulukko. Esimerkki havainnollistaa tätä toimintaa:

\begin{verbatim}
  int[] c;
  int[4] d;
  d[2] = 10;
  c = d;
  writeln(c[2]);
\end{verbatim}
Ohjelma tulostaa luvun 10. \\

D-kielen tarjoama struct ja union ovat useissa tilanteissa käyttökelpoisia,
varsinkin matalammalla tasolla, kuten esimerkiksi käyttöjärjestelmien
toteutuksessa. Koska ne ovat arvotyyppejä, niillä saadaan aikaan tehokkaita
rakenteita. D-kielen kehitykseen vaikuttaneista kielistä Java ei sisällä struct,
eikä union rakennetta. C\# sitä vastoin sisältää struct arvotyypin rakenteen
mutta ei unionia.

\subsection{Geneerisyys}
D-kielessä on tuki geneerisyydelle. Tämä tarkoittaa sitä, että funktio voidaan
kirjoittaa yleiseksi ilman, että sen parametreja sidotaan tiettyihin tyyppeihin.
Tällöin parametrin tyypiksi määritetään T. Seuraava esimerkki on toteutettu
geneerisyyttä hyödyntäen; binäärihaku, jolle voidaan antaa syötteeksi minkä
tahansa tyyppinen järjestetty taulukko.

\begin{verbatim}
bool binHaku(T)(T[] input, T value) {
  while (!input.empty) {
    int i = input.length / 2;
    auto mid = input[i];
    if (mid > value)
      input = input[0 .. i];
    else 
      if (mid < value)
        input = input[i + 1 .. $];
    else 
      return true;
  }
  return false;
}

void main() {
  writeln(binHaku([ 1, 3, 6, 7, 9, 15 ], 6));
  writeln(binHaku([ 'a', 'b', 'c', 'd', 'e', 'g', 'i' ], 'h'));
}
\end{verbatim}

Funktio hyväksyy syötteeksi järjestetyn taulukon ja suorittaa puolitushaun
sille. Ohjelman tuloste on seuraava:
\begin{verbatim}
true
false
\end{verbatim}

\subsection{Luokat ja periytyminen}
D-kielessä luokka voi periytyä vain yhdestä luokasta, toisin kuin C++ -kielessä,
jossa moniperintä on mahdollinen. D:ssä aliluokka perii kaikki yliluokan
tietueet ja funktiot. 
\begin{verbatim}
class Henkilo {
  string nimi;
  int ika;
  // luokan konstruktori
  this(string nimi, int ika) {
    this.nimi = nimi;
    this.ika = ika;
  }
  ~this() {} // tyhjäksi jätetty destruktori
}

class Opiskelija : Henkilo { // perii luoka Henkilo ominaisuudet
  string opiskelijaNumero;
  int opintoPisteet;
  string opintoLinja;
  // luokan konstruktori
  this(string nimi, int ika, string opiskelijaNumero) { 
    super(nimi, ika); // kutsuu yliluokan konstruktoria
    this.opiskelijaNumero = opiskelijaNumero;
  }
}

void main() {
  Opiskelija kapistelija = new Opiskelija("Kerttu Koodari", 29, "987234651");
  Opiskelija konnari = new Opiskelija("Kalle Konnari", 34, "132435467");
  kapistelija.opintoLinja = "Tietojenkasittelytiede";
  konnari.opintoLinja = "Kognitiotiede";
  kapistelija.opintoPisteet = 123;
  konnari.opintoPisteet = 87;
  writeln(kapistelija.nimi, "n opintopistekertyma on ",
kapistelija.opintoPisteet);
  writeln(konnari.nimi, "n opintopistekertyma on ", konnari.opintoPisteet);
}
\end{verbatim}
Ohjelma tulostaa seuraavasti:

\begin{verbatim}
Kerttu Koodarin opintopistekertyma on 123
Kalle Konnarin opintopistekertyma on 87
\end{verbatim}
Perinnän voi estää kirjoittamalla luokkamäärittelyn eteen final \cite{DLA13}.
Rajapintaluokka löytyy myös ja se määritetään luokkamäärittelyn edessä
avainsanalla interface. 
Abstrakti luokka voidaan muodostaa avainsanalla abstract, joka kirjoitetaan
luokan määrityksen eteen. Abstrakti luokka voi sisältää D-kielessä abstrakteja
funktioita, joille aliluokan on annettava toteutus, ja normaaleja funktioita.
Abstraktista luokasta ei voi luoda ilmentymää, vaan ainoastaan abstraktin luokan
aliluokasta voidaan luoda ilmentymä. Esimerkkikoodia abstraktin luokan
toteutuksesta:
\begin{verbatim}
// abstrakti luokka Tervehdys
abstract class Tervehdys { 
  void tervehdi(){ 
    writeln("Hei!"); 
  } 
  abstract void tervehdiNimella(string name); 
} 

class TervehdysNimella : Tervehdys { 
  // tervehdiNimella abstraktin funktion toteutus
  void tervehdiNimella(string nimi){ 
    writeln("Hei ", nimi, "!"); 
  } 
} 

void main() {

  Tervehdys tervehdys = new TervehdysNimella(); 
  tervehdys.tervehdi(); 
  tervehdys.tervehdiNimella("Kerttu"); 
}
\end{verbatim}
Ja ohjelma tulostaa:
\begin{verbatim}
Hei!
Hei Kerttu!
\end{verbatim}

D-kielessä on lisäksi tuki rajapintaluokille, joita voidaan periä useampia
yhdelle luokalle. Rajapintaluokassa määritellään funktiot, jotka aliluokan
täytyy toteuttaa. Alla esimerkki koodista, jossa luokassa Laskenta toteutetaan
rajapintaluokkien Summa ja Tulo funktiot.

\begin{verbatim}
interface Summa { 
  int summa(int a, int b); 
} 

interface Tulo {
  int tulo(int a, int b);
}

class Laskenta : Summa, Tulo { 
  int summa(int a, int b) { 
    return a+b;
  } 

  int tulo(int a, int b) {
    return a*b;
  }
} 

void main() {
  Laskenta laskuri = new Laskenta();
  writeln("3+4=", laskuri.summa(3, 4));
  writeln("3*4=", laskuri.tulo(3, 4));
}
\end{verbatim}
Esimerkkikoodi tulostaa:
\begin{verbatim}
3+4=7
3*4=12
\end{verbatim}
\subsection{Arvo- ja viitesemantiikka}
D-kielessä tietueet, struct ja union, noudattavat arvosemantiikkaa. Luokat
noudattavat viitesemantiikkaa. Arvosemantiikkaa noudattavat tietueet
tallennetaan muistissa pinoon ja niiden olemassaolo riippuu näkyvyysalueesta.
Viitesemantiikkaan perustuvien luokkien ilmentymille taas varataan muistia
keosta; pinoon laitetaan vain osoitin keon kohtaan, jossa luotu olio sijaitsee.
Funktiokutsun parametrit voidaan välittää arvoina tai viitteinä, samaan tapaan
kuin C/C++ -kielissä \cite{KRR88}. Kielessä on tätä varten varattu merkit * ja
\&, josta lyhyt esimerkki:
\begin{verbatim}
void main() {
  int x=10;
  int y=20;
  writeln(x,",",y);
  vaihda(&x, &y);
  writeln(x,",",y);
}

void vaihda(int *px, int *py)
{
  int temp;
  temp=*px;
  *px=*py;
  *py=temp;
}
\end{verbatim}
Koodissa vaihdetaan muistissa x:n ja y:n arvoja keskenään. main kutsuu funktiota
vaihda ja funktiolle välitetään parametrina x:n ja y:n muistiosoitteet \&x ja
\&y. vaihda-funktion parametrien tyypeiksi on määritetty osoittimet merkillä *.
Funktio tekee arvojen vaihtamisen suoria muistiosoitteita käyttäen. Tuloste on
seuraava:
\begin{verbatim}
10,20
20,10
\end{verbatim}

\section{Hansin osuus}

\section{Eeron osuus}

(ordsets,  sets, gb_Sets,  sofs(set_of_sets)))

Erlang-kielessä set-tietorakenteet eli joukot ovat elementtien kokoelmia
(collection), joissa mistään elementistä ei ole kaksoiskappaleita. Erlangissa on
neljä moduulia joukkojen käsittelyyn: ordsets, sets, gb_sets ja sofs (sets of
sets). Fred Hébertin mukaan suunnittelijoiden tausta-ajatuksena oli, ettei
joukon esittämiseen ole yhtä, optimaalista tapaa.

ORDSETS

Ordsets-moduulissa järjestyksessä olevaa listaa käytetään joukon elementtien
tallentamiseen. (manuaali) Ordsets-rakenteet ovat hyödyllisiä lähinnä pienten
joukkojen esittämiseen. Ordsets-rakenteet ovat hitaita, mutta niiden esitystapa
on kaikista Erlangin joukkorakenteista yksinkertaisin ja helppolukuisin. Alla on
esimerkkejä ordsets-moduulin funktioista. (hepe)

\begin{verbatim}
ordsets:new/0
ordsets:is_element/2
ordsets:add_element/2
ordsets:del_element/2
ordsets:union/1
ordsets:intersection/1
\end{verbatim}

Ordsets-moduulin esitystapa eroaa sets-moduulin esitystavasta yhdellä tavalla.
Siinä missä sets-moduuli olettaa kahden elementin olevan erilaisia, jos ne eivät
ole täysin samat (=:=), ordsets-moduulissa kaksi elementtiä eroavat toisistaan
ainoastaan, jos ne eivät compare equal KORJAA (==). (manuaali)


SETS

Sets-moduuli muistuttaa Orsets-moduulia, mutta 

This module provides exactly the same interface as the module ordsets but with a
defined representation. One difference is that while this module considers two
elements as different if they do not match (=:=), ordsets considers two elements
as different if and only if they do not compare equal (==).

sets
Sets (the module) is implemented on top of a structure really similar to the one
used in dict. They implement the same interface as ordsets, but they're going to
scale much better. Like dictionaries, they're especially good for read-intensive
manipulations, like checking whether some element is part of the set or not.

GB_SETS

An implementation of ordered sets using Prof. Arne Andersson's General Balanced
Trees. This can be much more efficient than using ordered lists, for larger
sets, but depends on the application.

This module considers two elements as different if and only if they do not
compare equal (==).

Complexity note

The complexity on set operations is bounded by either O(|S|) or O(|T| *
log(|S|)), where S is the largest given set, depending on which is fastest for
any particular function call. For operating on sets of almost equal size, this
implementation is about 3 times slower than using ordered-list sets directly.
For sets of very different sizes, however, this solution can be arbitrarily much
faster; in practical cases, often between 10 and 100 times. This implementation
is particularly suited for accumulating elements a few at a time, building up a
large set (more than 100-200 elements), and repeatedly testing for membership in
the current set.

As with normal tree structures, lookup (membership testing), insertion and
deletion have logarithmic complexity.

gb_sets
Gb_sets themselves are constructed above a General Balanced Tree structure
similar to the one used in the gb_trees module. gb_sets are to sets what gb_tree
is to dict; an implementation that is faster when considering operations
different than reading, leaving you with more control. While gb_sets implement
the same interface as sets and ordsets, they also add more functions. Like
gb_trees, you have smart vs. naive functions, iterators, quick access to the
smallest and largest values, etc.

SOFS

The sofs module implements operations on finite sets and relations represented
as sets. Intuitively, a set is a collection of elements; every element belongs
to the set, and the set contains every element.

sofs
Sets of sets (sofs) are implemented with sorted lists, stuck inside a tuple with
some metadata. They're the module to use if you want to have full control over
relationships between sets, families, enforce set types, etc. They're really
what you want if you need mathematics concept rather than 'just' groups of
unique elements.

MUUTA

Don't drink too much kool-aid:
While such a variety can be seen as something great, some implementation details
can be downright frustrating. As an example, gb_sets, ordsets and sofs all use
the == operator to compare values: if you have the numbers 2 and 2.0, they'll
both end up seen as the same one.

However, sets (the module) uses the =:= operator, which means you can't
necessarily switch over every implementation as you wish. There are cases where
you need one precise behavior and at that point, you might lose the benefit of
having multiple implementations.

It's a bit confusing to have that many options available. Björn Gustavsson, from
the Erlang/OTP team and programmer of Wings3D mainly suggests using gb_sets in
most circumstances, using ordset when you need a clear representation that you
want to process with your own code and 'sets' when you need the =:= operator
(source.)

In any case, like for key-value stores, the best solution is usually to
benchmark and see what fits your application better.

\bibliography{Lähteet}


\begin{thebibliography}{99}

\bibitem[ERL99]{ERL99} Erlang 4.7.3 Reference Manual, DRAFT (0.7), Jonas
Barklund, Robert Virding, 1999. 

\bibitem[DLA13]{DLA13} http://dlang.org, noudettu 6.2.2013.

\bibitem[HEB13]{HEB13} Learn You Some Erlang For Great Good, Fred Hébert, 2013.

\bibitem[ALE10]{ALE10} The D Programming Language, Andrei Alexandrescu, 2010.

\bibitem[KRR88]{KRR88} The C Programming Language, Brian W. Kernighan, Dennis M.
Ritchie, 1978/1988.

\end{thebibliography}

\end{document}