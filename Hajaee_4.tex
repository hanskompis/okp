\documentclass[11pt,oneside,a4paper]{article}
\usepackage{url}
\usepackage{hyperref}
\usepackage{lmodern}
\usepackage[pdftex]{graphicx}
\usepackage{textcomp}
\usepackage[utf8]{inputenc}
\usepackage[finnish]{babel}
\usepackage[T1]{fontenc}
\title{D- ja Erlang-kielten datan kapselointi}
\author{Hansi Keijonen, Jari Koskinen, Eero Laine}

\begin{document}

\maketitle

\newpage

\section{Jarin osuus}
\subsection{Rakenteiset tyypit}
Alkeistyypeistä voidaan muodostaa taulukoita, joita on kahdenlaisia. Yksi taulukoista on yleinen perustapaus array, jollainen löytyy myös C/C++-kielistä. Taulukon alkioihin voidaan viitata indeksin avulla.
\begin{verbatim}
int[] lukuja;
lukuja[11] = 13;
\end{verbatim}

Toinen taulukkomuoto on avaimen ja arvon sisältävä pari, associative array. Taulukon alkio sisältää arvon ja siihen viittaava indeksi on esimerkiksi merkkijono: 
\begin{verbatim}
  int[string] kuukausi;
  
  kuukausi["tammikuu"] = 1;
  kuukausi["helmikuu"] = 2;
  
  writeln("Tammikuu=", kuukausi["tammikuu"]);
\end{verbatim}
Koodi tulostaa:
\begin{verbatim}
Tammikuu=1
\end{verbatim}

Lisäksi taulukko voidaan jättää dynaamiseksi, määrittämällä sen pituudeksi [], jolloin sille voidaan osoittaa jokin olemassa oleva taulukko myöhemmin koodissa. ** PALAA TÄHÄN!! **

Alkeistyypeistä voidaan myös muodostaa tietueet struct tai union. Molemmat vastaavat C/C++-kielen vastaavia rakenteita ja ovat arvotyyppejä \cite{DLA13}. Struct määritellään, ja sitä käytetään seuraavasti:

\begin{verbatim}
struct palkansaaja{
  int palkka;
  string titteli;
}

void main() {
  palkansaaja[5] palkolliset;
  palkolliset[1].palkka = 4500;
  palkolliset[1].titteli = "ohjelmoija";

  write(palkolliset[1].titteli, " tienaa ");
  writeln(palkolliset[1].palkka, " kuukaudessa");
}
\end{verbatim}

Union eroaa structista siten, että muuttujien arvot on talletettu muistissa samaan kohtaan \cite{ALE10};\cite{KRR88}, riippumatta niiden tyypistä ja pituudesta. Kääntäjän tehtävä on varata riittävä määrä muistia suurimman tyypin mukaisesti. Yhden muuttujan arvon muuttaminen vaihtaa muuttujille varatun muistin sisällön. Seuraava esimerkki havainnollistaa tätä:
\begin{verbatim}
union moniTyyppi{
  int iluku;
  uint uiluku;
  byte bluku;
}

void main() {
  moniTyyppi luku;
  luku.iluku = 6200;
  writeln("int: ", luku.iluku);
  writeln("uint: ", luku.uiluku);
  writeln("byte: ", luku.bluku);
  luku.iluku = -6200;
  writeln("int: ", luku.iluku);
  writeln("uint: ", luku.uiluku);
  writeln("byte: ", luku.bluku);
}
\end{verbatim}
Ohjelma tulostaa seuraavasti:

\begin{verbatim}
int: 6200
uint: 6200
byte: 56
int: -6200
uint: 4294961096
byte: -56
\end{verbatim}

Lisäksi voidaan luoda dymaaninen taulukko, joka tarkoittaa sitä, että taulukkoon voidaan myöhemmin sijoittaa taulukko. Esimerkki havainnollistaa tätä toimintaa:

\begin{verbatim}
  int[] c;
  int[4] d;
  d[2] = 10;
  c = d;
  writeln(c[2]);
\end{verbatim}
Ohjelma tulostaa luvun 10. \\
Taulukko voidaan myös osoittaa tiettyyn muistialueeseen. JATKA POINTER JNE. \\


D-kielen tarjoama struct ja union ovat useissa tilanteissa käyttökelpoisia, varsinkin matalammalla tasolla, kuten esimerkiksi käyttöjärjestelmien toteutuksessa. Koska ne ovat arvotyyppejä, niillä saadaan aikaan tehokkaita rakenteita. D-kielen kehitykseen vaikuttaneista kielistä Java ei sisällä struct, eikä union rakennetta. C\# sitä vastoin sisältää struct arvotyypin rakenteen mutta ei unionia.

\subsection{Geneerisyys}
D-kielessä on tuki geneerisyydelle. Tämä tarkoittaa sitä, että funktio voidaan kirjoittaa yleiseksi ilman, että sen tyyppejä sidotaan tiettyihin tyyppeihin. Seuraava esimerkki on toteutettu geneerisyyttä hyödyntäen; binäärihaku, jolle voidaan antaa syötteeksi minkä tahansa tyyppinen järjestetty taulukko.

\begin{verbatim}
bool binHaku(T)(T[] input, T value) {
  while (!input.empty) {
    int i = input.length / 2;
    auto mid = input[i];
    if (mid > value)
      input = input[0 .. i];
    else 
      if (mid < value)
        input = input[i + 1 .. $];
    else 
      return true;
  }
  return false;
}

void main() {
  writeln(binHaku([ 1, 3, 6, 7, 9, 15 ], 6));
  writeln(binHaku([ 'a', 'b', 'c', 'd', 'e', 'g', 'i' ], 'h'));
}
\end{verbatim}

Funktio hyväksyy syötteeksi järjestetyn taulukon ja suorittaa puolitushaun sille. Ohjelman tuloste on seuraava:
\begin{verbatim}
true
false
\end{verbatim}

\subsection{Luokat ja periytyminen}
D-kielessä luokka voi periytyä vain yhdestä luokasta, toisin kuin C++ -kielessä, jossa on moniperintä mahdollinen. D:ssä aliluokka perii kaikki yliluokan tietueet ja funktiot. Perinnän voi estää kirjoittamalla luokkamäärittelyn eteen final. 
\begin{verbatim}
class Henkilo {
  string nimi;
  int ika;
  // luokan konstruktori
  this(string nimi, int ika) {
    this.nimi = nimi;
    this.ika = ika;
  }
  ~this() {} // tyhjäksi jätetty destruktori
}

class Opiskelija : Henkilo { // perii luoka Henkilo ominaisuudet
  string opiskelijaNumero;
  int opintoPisteet;
  string opintoLinja;
  // luokan konstruktori
  this(string nimi, int ika, string opiskelijaNumero) { 
    super(nimi, ika); // kutsuu yliluokan konstruktoria
    this.opiskelijaNumero = opiskelijaNumero;
  }
}

void main() {
  Opiskelija kapistelija = new Opiskelija("Kerttu Koodari", 29, "987234651");
  Opiskelija konnari = new Opiskelija("Kalle Konnari", 34, "132435467");
  kapistelija.opintoLinja = "Tietojenkasittelytiede";
  konnari.opintoLinja = "Kognitiotiede";
  kapistelija.opintoPisteet = 123;
  konnari.opintoPisteet = 87;
  writeln(kapistelija.nimi, "n opintopistekertyma on ", kapistelija.opintoPisteet);
  writeln(konnari.nimi, "n opintopistekertyma on ", konnari.opintoPisteet);
}
\end{verbatim}
Ohjelma tulostaa seuraavasti:

\begin{verbatim}
Kerttu Koodarin opintopistekertyma on 123
Kalle Konnarin opintopistekertyma on 87
\end{verbatim}
\section{Hansin osuus}

\section{Eeron osuus}



\bibliography{Lähteet}


\begin{thebibliography}{99}

\bibitem[ERL99]{ERL99} Erlang 4.7.3 Reference Manual, DRAFT (0.7), Jonas
Barklund, Robert Virding, 1999. 

\bibitem[DLA13]{DLA13} http://dlang.org, noudettu 6.2.2013.

\bibitem[HEB13]{HEB13} Learn You Some Erlang For Great Good, Fred Hébert, 2013.

\bibitem[ALE10]{ALE10} The D Programming Language, Andrei Alexandrescu, 2010.

\bibitem[KRR88]{KRR88} The C Programming Language, Brian W. Kernighan, Dennis M. Ritchie, 1978/1988.

\end{thebibliography}

\end{document}