\documentclass[11pt,oneside,a4paper]{article}
\usepackage{url}
\usepackage{hyperref}
\usepackage{lmodern}
\usepackage[pdftex]{graphicx}
\usepackage{textcomp}
\usepackage[utf8]{inputenc}
\usepackage[finnish]{babel}
\usepackage[T1]{fontenc}
\title{D- ja Erlang-kielten datan kapselointi}
\author{Hansi Keijonen, Jari Koskinen, Eero Laine}

\begin{document}

\maketitle

\newpage

\section{Jarin osuus}
\subsection{Rakenteiset tyypit}
Alkeistyypeistä voidaan muodostaa taulukoita, joita on kahdenlaisia. Yksi taulukoista on yleinen perustapaus array, jollainen löytyy myös C/C++-kielistä \cite{KRR88}. Taulukon alkioihin voidaan viitata indeksin avulla.
\begin{verbatim}
int[] lukuja;
lukuja[11] = 13;
\end{verbatim}

Toinen taulukkomuoto on avaimen ja arvon sisältävä pari, associative array. Taulukon alkio sisältää arvon ja siihen viittaava indeksi voi olla esimerkiksi merkkijono: 
\begin{verbatim}
  int[string] kuukausi;
  
  kuukausi["tammikuu"] = 1;
  kuukausi["helmikuu"] = 2;
  
  writeln("Tammikuu=", kuukausi["tammikuu"]);
\end{verbatim}
Koodi tulostaa:
\begin{verbatim}
Tammikuu=1
\end{verbatim}

Lisäksi taulukko voidaan jättää dynaamiseksi, määrittämällä sen pituudeksi [], jolloin sille voidaan osoittaa jokin olemassa oleva taulukko myöhemmin koodissa.

Alkeistyypeistä voidaan myös muodostaa tietueet struct tai union. Molemmat vastaavat C/C++-kielen vastaavia rakenteita \cite{KRR88} ja ovat arvotyyppejä \cite{DLA13}. Struct määritellään, ja sitä käytetään seuraavasti:

\begin{verbatim}
struct palkansaaja{
  int palkka;
  string titteli;
}

void main() {
  palkansaaja[5] palkolliset;
  palkolliset[1].palkka = 4500;
  palkolliset[1].titteli = "ohjelmoija";

  write(palkolliset[1].titteli, " tienaa ");
  writeln(palkolliset[1].palkka, " kuukaudessa");
}
\end{verbatim}

Union eroaa structista siten, että muuttujien arvot on talletettu muistissa samaan kohtaan \cite{ALE10};\cite{KRR88}, riippumatta niiden tyypistä ja pituudesta. Kääntäjän tehtävä on varata riittävä määrä muistia suurimman tyypin mukaisesti. Yhden muuttujan arvon muuttaminen vaihtaa muuttujille varatun muistin sisällön. Seuraava esimerkki havainnollistaa tätä:
\begin{verbatim}
union moniTyyppi{
  int iluku;
  uint uiluku;
  ubyte ubluku;
}

void main() {
  moniTyyppi luku;
  luku.iluku = 6200;
  writeln("int: ", luku.iluku);
  writeln("uint: ", luku.uiluku);
  writeln("ubyte: ", luku.ubluku);
  luku.iluku = -6200;
  writeln("int: ", luku.iluku);
  writeln("uint: ", luku.uiluku);
  writeln("ubyte: ", luku.ubluku);
}
\end{verbatim}
Ohjelma tulostaa seuraavasti:

\begin{verbatim}
int: 6200
uint: 6200
byte: 56
int: -6200
uint: 4294961096
ubyte: 200
\end{verbatim}

Lisäksi voidaan luoda dymaaninen taulukko, joka tarkoittaa sitä, että taulukkoon voidaan myöhemmin sijoittaa taulukko. Esimerkki havainnollistaa tätä toimintaa:

\begin{verbatim}
  int[] c;
  int[4] d;
  d[2] = 10;
  c = d;
  writeln(c[2]);
\end{verbatim}
Ohjelma tulostaa luvun 10. \\

D-kielen tarjoama struct ja union ovat useissa tilanteissa käyttökelpoisia, varsinkin matalammalla tasolla, kuten esimerkiksi käyttöjärjestelmien toteutuksessa. Koska ne ovat arvotyyppejä, niillä saadaan aikaan tehokkaita rakenteita. D-kielen kehitykseen vaikuttaneista kielistä Java ei sisällä struct, eikä union rakennetta. C\# sitä vastoin sisältää struct arvotyypin rakenteen mutta ei unionia.

\subsection{Geneerisyys}
D-kielessä on tuki geneerisyydelle. Tämä tarkoittaa sitä, että funktio voidaan kirjoittaa yleiseksi ilman, että sen parametreja sidotaan tiettyihin tyyppeihin. Tällöin parametrin tyypiksi määritetään T. Seuraava esimerkki on toteutettu geneerisyyttä hyödyntäen; binäärihaku, jolle voidaan antaa syötteeksi minkä tahansa tyyppinen järjestetty taulukko.

\begin{verbatim}
bool binHaku(T)(T[] input, T value) {
  while (!input.empty) {
    int i = input.length / 2;
    auto mid = input[i];
    if (mid > value)
      input = input[0 .. i];
    else 
      if (mid < value)
        input = input[i + 1 .. $];
    else 
      return true;
  }
  return false;
}

void main() {
  writeln(binHaku([ 1, 3, 6, 7, 9, 15 ], 6));
  writeln(binHaku([ 'a', 'b', 'c', 'd', 'e', 'g', 'i' ], 'h'));
}
\end{verbatim}

Funktio hyväksyy syötteeksi järjestetyn taulukon ja suorittaa puolitushaun sille. Ohjelman tuloste on seuraava:
\begin{verbatim}
true
false
\end{verbatim}

\subsection{Luokat ja periytyminen}
D-kielessä luokka voi periytyä vain yhdestä luokasta, toisin kuin C++ -kielessä, jossa moniperintä on mahdollinen. D:ssä aliluokka perii kaikki yliluokan tietueet ja funktiot. 
\begin{verbatim}
class Henkilo {
  string nimi;
  int ika;
  // luokan konstruktori
  this(string nimi, int ika) {
    this.nimi = nimi;
    this.ika = ika;
  }
  ~this() {} // tyhjäksi jätetty destruktori
}

class Opiskelija : Henkilo { // perii luoka Henkilo ominaisuudet
  string opiskelijaNumero;
  int opintoPisteet;
  string opintoLinja;
  // luokan konstruktori
  this(string nimi, int ika, string opiskelijaNumero) { 
    super(nimi, ika); // kutsuu yliluokan konstruktoria
    this.opiskelijaNumero = opiskelijaNumero;
  }
}

void main() {
  Opiskelija kapistelija = new Opiskelija("Kerttu Koodari", 29, "987234651");
  Opiskelija konnari = new Opiskelija("Kalle Konnari", 34, "132435467");
  kapistelija.opintoLinja = "Tietojenkasittelytiede";
  konnari.opintoLinja = "Kognitiotiede";
  kapistelija.opintoPisteet = 123;
  konnari.opintoPisteet = 87;
  writeln(kapistelija.nimi, "n opintopistekertyma on ", kapistelija.opintoPisteet);
  writeln(konnari.nimi, "n opintopistekertyma on ", konnari.opintoPisteet);
}
\end{verbatim}
Ohjelma tulostaa seuraavasti:

\begin{verbatim}
Kerttu Koodarin opintopistekertyma on 123
Kalle Konnarin opintopistekertyma on 87
\end{verbatim}
Perinnän voi estää kirjoittamalla luokkamäärittelyn eteen final \cite{DLA13}. Rajapintaluokka löytyy myös ja se määritetään luokkamäärittelyn edessä avainsanalla interface. 
Abstrakti luokka voidaan muodostaa avainsanalla abstract, joka kirjoitetaan luokan määrityksen eteen. Abstrakti luokka voi sisältää D-kielessä abstrakteja funktioita, joille aliluokan on annettava toteutus, ja normaaleja funktioita. Abstraktista luokasta ei voi luoda ilmentymää, vaan ainoastaan abstraktin luokan aliluokasta voidaan luoda ilmentymä. Esimerkkikoodia abstraktin luokan toteutuksesta:
\begin{verbatim}
// abstrakti luokka Tervehdys
abstract class Tervehdys { 
  void tervehdi(){ 
    writeln("Hei!"); 
  } 
  abstract void tervehdiNimella(string name); 
} 

class TervehdysNimella : Tervehdys { 
  // tervehdiNimella abstraktin funktion toteutus
  void tervehdiNimella(string nimi){ 
    writeln("Hei ", nimi, "!"); 
  } 
} 

void main() {

  Tervehdys tervehdys = new TervehdysNimella(); 
  tervehdys.tervehdi(); 
  tervehdys.tervehdiNimella("Kerttu"); 
}
\end{verbatim}
Ja ohjelma tulostaa:
\begin{verbatim}
Hei!
Hei Kerttu!
\end{verbatim}

D-kielessä on lisäksi tuki rajapintaluokille, joita voidaan periä useampia yhdelle luokalle. Rajapintaluokassa määritellään funktiot, jotka aliluokan täytyy toteuttaa. Alla esimerkki koodista, jossa luokassa Laskenta toteutetaan rajapintaluokkien Summa ja Tulo funktiot.

\begin{verbatim}
interface Summa { 
  int summa(int a, int b); 
} 

interface Tulo {
  int tulo(int a, int b);
}

class Laskenta : Summa, Tulo { 
  int summa(int a, int b) { 
    return a+b;
  } 

  int tulo(int a, int b) {
    return a*b;
  }
} 

void main() {
  Laskenta laskuri = new Laskenta();
  writeln("3+4=", laskuri.summa(3, 4));
  writeln("3*4=", laskuri.tulo(3, 4));
}
\end{verbatim}
Esimerkkikoodi tulostaa:
\begin{verbatim}
3+4=7
3*4=12
\end{verbatim}
\subsection{Arvo- ja viitesemantiikka}
D-kielessä tietueet, struct ja union, noudattavat arvosemantiikkaa. Luokat noudattavat viitesemantiikkaa. Arvosemantiikkaa noudattavat tietueet tallennetaan muistissa pinoon ja niiden olemassaolo riippuu näkyvyysalueesta. Viitesemantiikkaan perustuvien luokkien ilmentymille taas varataan muistia keosta; pinoon laitetaan vain osoitin keon kohtaan, jossa luotu olio sijaitsee. Funktiokutsun parametrit voidaan välittää arvoina tai viitteinä, samaan tapaan kuin C/C++ -kielissä \cite{KRR88}. Kielessä on tätä varten varattu merkit * ja \&, josta lyhyt esimerkki:
\begin{verbatim}
void main() {
  int x=10;
  int y=20;
  writeln(x,",",y);
  vaihda(&x, &y);
  writeln(x,",",y);
}

void vaihda(int *px, int *py)
{
  int temp;
  temp=*px;
  *px=*py;
  *py=temp;
}
\end{verbatim}
Koodissa vaihdetaan muistissa x:n ja y:n arvoja keskenään. main kutsuu funktiota vaihda ja funktiolle välitetään parametrina x:n ja y:n muistiosoitteet \&x ja \&y. vaihda-funktion parametrien tyypeiksi on määritetty osoittimet merkillä *. Funktio tekee arvojen vaihtamisen suoria muistiosoitteita käyttäen. Tuloste on seuraava:
\begin{verbatim}
10,20
20,10
\end{verbatim}

\section{Hansin osuus}

\section{Eeron osuus}



\bibliography{Lähteet}


\begin{thebibliography}{99}

\bibitem[ERL99]{ERL99} Erlang 4.7.3 Reference Manual, DRAFT (0.7), Jonas
Barklund, Robert Virding, 1999. 

\bibitem[DLA13]{DLA13} http://dlang.org, noudettu 6.2.2013.

\bibitem[HEB13]{HEB13} Learn You Some Erlang For Great Good, Fred Hébert, 2013.

\bibitem[ALE10]{ALE10} The D Programming Language, Andrei Alexandrescu, 2010.

\bibitem[KRR88]{KRR88} The C Programming Language, Brian W. Kernighan, Dennis M. Ritchie, 1978/1988.

\end{thebibliography}

\end{document}